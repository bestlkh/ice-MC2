{"version":3,"sources":["ImageUtility.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","debug","EXIF","this","EXIFwrapped","ExifTags","Tags","36864","40960","40961","40962","40963","37121","37122","37500","37510","40964","36867","36868","37520","37521","37522","33434","33437","34850","34852","34855","34856","37377","37378","37379","37380","37381","37382","37383","37384","37385","37396","37386","41483","41484","41486","41487","41488","41492","41493","41495","41728","41729","41730","41985","41986","41987","41988","41989","41990","41991","41992","41993","41994","41995","41996","40965","42016","TiffTags","256","257","34665","34853","258","259","262","274","277","284","530","531","282","283","296","273","278","279","513","514","301","318","319","529","532","306","270","271","272","305","315","33432","GPSTags","0","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","IFD1Tags","StringValues","ExposureProgram","MeteringMode","255","LightSource","Flash","31","32","65","69","71","73","77","79","89","93","95","SensingMethod","SceneCaptureType","SceneType","CustomRendered","WhiteBalance","GainControl","Contrast","Saturation","Sharpness","SubjectDistanceRange","FileSource","Components","imageHasData","img","exifdata","getImageData","callback","handleBinaryFile","binFile","data","findEXIFinJPEG","iptcdata","file","dataView","DataView","console","log","byteLength","getUint8","offset","isFieldSegmentStart","nameHeaderLength","startOffset","sectionLength","getUint16","readIPTCData","findIPTCinJPEG","isXmpEnabled","xmpdata","self","dom","DOMParser","getStringFromDB","xmpString","xmpEndIndex","indexOf","indexOfXmp","substring","slice","domDocument","parseFromString","xml2Object","findXMPinJPEG","url","http","src","test","base64","contentType","match","replace","binary","atob","len","buffer","ArrayBuffer","view","Uint8Array","charCodeAt","base64ToArrayBuffer","fileReader","FileReader","onload","target","result","blob","readAsArrayBuffer","XMLHttpRequest","open","responseType","status","response","send","Blob","File","marker","readEXIFData","IptcFieldMap","120","110","55","80","85","122","105","116","fieldValue","fieldName","dataSize","segmentType","segmentStartPos","getInt16","hasOwnProperty","Array","push","readTags","tiffStart","dirStart","strings","bigEnd","entryOffset","tag","entries","tags","readTagValue","vals","val","numerator","denominator","type","numValues","getUint32","valueOffset","Number","getInt32","start","outstr","String","fromCharCode","exifData","gpsData","tiffOffset","firstIFDOffset","ExifIFDPointer","GPSInfoIFDPointer","IFD1OffsetPointer","thumbTags","JpegIFOffset","JpegIFByteCount","tOffset","tLength","readThumbnailImage","xml2json","xml","json","nodeType","attributes","j","attribute","item","nodeName","nodeValue","hasChildNodes","childNodes","child","old","children","idx","itemAtt","dataKey","dataValue","undefined","textContent","message","enableXmp","disableXmp","getData","Image","HTMLImageElement","complete","getTag","getIptcTag","getAllTags","getAllIptcTags","pretty","strPretty","readFromBinaryFile","define","amd","_rotateImage","direction","canvas","height","width","step","degree","Math","PI","ctx","getContext","drawImage","rotate","iOSOrientationAutoFix","orientation","oritentation","fr","readAsDataURL","addEventListener","document","createElement","navigator","userAgent","toDataURL","window","ImageUtility","exif-js"],"mappings":"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","file":"ImageUtility.js","sourcesContent":["\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function () {\n    function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = typeof require == \"function\" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error(\"Cannot find module '\" + o + \"'\");throw f.code = \"MODULE_NOT_FOUND\", f;\n                }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {\n                    var n = t[o][1][e];return s(n ? n : e);\n                }, l, l.exports, e, t, n, r);\n            }return n[o].exports;\n        }var i = typeof require == \"function\" && require;for (var o = 0; o < r.length; o++) {\n            s(r[o]);\n        }return s;\n    }return e;\n})()({ 1: [function (require, module, exports) {\n        (function () {\n\n            var debug = false;\n\n            var root = this;\n\n            var EXIF = function EXIF(obj) {\n                if (obj instanceof EXIF) return obj;\n                if (!(this instanceof EXIF)) return new EXIF(obj);\n                this.EXIFwrapped = obj;\n            };\n\n            if (typeof exports !== 'undefined') {\n                if (typeof module !== 'undefined' && module.exports) {\n                    exports = module.exports = EXIF;\n                }\n                exports.EXIF = EXIF;\n            } else {\n                root.EXIF = EXIF;\n            }\n\n            var ExifTags = EXIF.Tags = {\n\n                // version tags\n                0x9000: \"ExifVersion\", // EXIF version\n                0xA000: \"FlashpixVersion\", // Flashpix format version\n\n                // colorspace tags\n                0xA001: \"ColorSpace\", // Color space information tag\n\n                // image configuration\n                0xA002: \"PixelXDimension\", // Valid width of meaningful image\n                0xA003: \"PixelYDimension\", // Valid height of meaningful image\n                0x9101: \"ComponentsConfiguration\", // Information about channels\n                0x9102: \"CompressedBitsPerPixel\", // Compressed bits per pixel\n\n                // user information\n                0x927C: \"MakerNote\", // Any desired information written by the manufacturer\n                0x9286: \"UserComment\", // Comments by user\n\n                // related file\n                0xA004: \"RelatedSoundFile\", // Name of related sound file\n\n                // date and time\n                0x9003: \"DateTimeOriginal\", // Date and time when the original image was generated\n                0x9004: \"DateTimeDigitized\", // Date and time when the image was stored digitally\n                0x9290: \"SubsecTime\", // Fractions of seconds for DateTime\n                0x9291: \"SubsecTimeOriginal\", // Fractions of seconds for DateTimeOriginal\n                0x9292: \"SubsecTimeDigitized\", // Fractions of seconds for DateTimeDigitized\n\n                // picture-taking conditions\n                0x829A: \"ExposureTime\", // Exposure time (in seconds)\n                0x829D: \"FNumber\", // F number\n                0x8822: \"ExposureProgram\", // Exposure program\n                0x8824: \"SpectralSensitivity\", // Spectral sensitivity\n                0x8827: \"ISOSpeedRatings\", // ISO speed rating\n                0x8828: \"OECF\", // Optoelectric conversion factor\n                0x9201: \"ShutterSpeedValue\", // Shutter speed\n                0x9202: \"ApertureValue\", // Lens aperture\n                0x9203: \"BrightnessValue\", // Value of brightness\n                0x9204: \"ExposureBias\", // Exposure bias\n                0x9205: \"MaxApertureValue\", // Smallest F number of lens\n                0x9206: \"SubjectDistance\", // Distance to subject in meters\n                0x9207: \"MeteringMode\", // Metering mode\n                0x9208: \"LightSource\", // Kind of light source\n                0x9209: \"Flash\", // Flash status\n                0x9214: \"SubjectArea\", // Location and area of main subject\n                0x920A: \"FocalLength\", // Focal length of the lens in mm\n                0xA20B: \"FlashEnergy\", // Strobe energy in BCPS\n                0xA20C: \"SpatialFrequencyResponse\", //\n                0xA20E: \"FocalPlaneXResolution\", // Number of pixels in width direction per FocalPlaneResolutionUnit\n                0xA20F: \"FocalPlaneYResolution\", // Number of pixels in height direction per FocalPlaneResolutionUnit\n                0xA210: \"FocalPlaneResolutionUnit\", // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\n                0xA214: \"SubjectLocation\", // Location of subject in image\n                0xA215: \"ExposureIndex\", // Exposure index selected on camera\n                0xA217: \"SensingMethod\", // Image sensor type\n                0xA300: \"FileSource\", // Image source (3 == DSC)\n                0xA301: \"SceneType\", // Scene type (1 == directly photographed)\n                0xA302: \"CFAPattern\", // Color filter array geometric pattern\n                0xA401: \"CustomRendered\", // Special processing\n                0xA402: \"ExposureMode\", // Exposure mode\n                0xA403: \"WhiteBalance\", // 1 = auto white balance, 2 = manual\n                0xA404: \"DigitalZoomRation\", // Digital zoom ratio\n                0xA405: \"FocalLengthIn35mmFilm\", // Equivalent foacl length assuming 35mm film camera (in mm)\n                0xA406: \"SceneCaptureType\", // Type of scene\n                0xA407: \"GainControl\", // Degree of overall image gain adjustment\n                0xA408: \"Contrast\", // Direction of contrast processing applied by camera\n                0xA409: \"Saturation\", // Direction of saturation processing applied by camera\n                0xA40A: \"Sharpness\", // Direction of sharpness processing applied by camera\n                0xA40B: \"DeviceSettingDescription\", //\n                0xA40C: \"SubjectDistanceRange\", // Distance to subject\n\n                // other tags\n                0xA005: \"InteroperabilityIFDPointer\",\n                0xA420: \"ImageUniqueID\" // Identifier assigned uniquely to each image\n            };\n\n            var TiffTags = EXIF.TiffTags = {\n                0x0100: \"ImageWidth\",\n                0x0101: \"ImageHeight\",\n                0x8769: \"ExifIFDPointer\",\n                0x8825: \"GPSInfoIFDPointer\",\n                0xA005: \"InteroperabilityIFDPointer\",\n                0x0102: \"BitsPerSample\",\n                0x0103: \"Compression\",\n                0x0106: \"PhotometricInterpretation\",\n                0x0112: \"Orientation\",\n                0x0115: \"SamplesPerPixel\",\n                0x011C: \"PlanarConfiguration\",\n                0x0212: \"YCbCrSubSampling\",\n                0x0213: \"YCbCrPositioning\",\n                0x011A: \"XResolution\",\n                0x011B: \"YResolution\",\n                0x0128: \"ResolutionUnit\",\n                0x0111: \"StripOffsets\",\n                0x0116: \"RowsPerStrip\",\n                0x0117: \"StripByteCounts\",\n                0x0201: \"JPEGInterchangeFormat\",\n                0x0202: \"JPEGInterchangeFormatLength\",\n                0x012D: \"TransferFunction\",\n                0x013E: \"WhitePoint\",\n                0x013F: \"PrimaryChromaticities\",\n                0x0211: \"YCbCrCoefficients\",\n                0x0214: \"ReferenceBlackWhite\",\n                0x0132: \"DateTime\",\n                0x010E: \"ImageDescription\",\n                0x010F: \"Make\",\n                0x0110: \"Model\",\n                0x0131: \"Software\",\n                0x013B: \"Artist\",\n                0x8298: \"Copyright\"\n            };\n\n            var GPSTags = EXIF.GPSTags = {\n                0x0000: \"GPSVersionID\",\n                0x0001: \"GPSLatitudeRef\",\n                0x0002: \"GPSLatitude\",\n                0x0003: \"GPSLongitudeRef\",\n                0x0004: \"GPSLongitude\",\n                0x0005: \"GPSAltitudeRef\",\n                0x0006: \"GPSAltitude\",\n                0x0007: \"GPSTimeStamp\",\n                0x0008: \"GPSSatellites\",\n                0x0009: \"GPSStatus\",\n                0x000A: \"GPSMeasureMode\",\n                0x000B: \"GPSDOP\",\n                0x000C: \"GPSSpeedRef\",\n                0x000D: \"GPSSpeed\",\n                0x000E: \"GPSTrackRef\",\n                0x000F: \"GPSTrack\",\n                0x0010: \"GPSImgDirectionRef\",\n                0x0011: \"GPSImgDirection\",\n                0x0012: \"GPSMapDatum\",\n                0x0013: \"GPSDestLatitudeRef\",\n                0x0014: \"GPSDestLatitude\",\n                0x0015: \"GPSDestLongitudeRef\",\n                0x0016: \"GPSDestLongitude\",\n                0x0017: \"GPSDestBearingRef\",\n                0x0018: \"GPSDestBearing\",\n                0x0019: \"GPSDestDistanceRef\",\n                0x001A: \"GPSDestDistance\",\n                0x001B: \"GPSProcessingMethod\",\n                0x001C: \"GPSAreaInformation\",\n                0x001D: \"GPSDateStamp\",\n                0x001E: \"GPSDifferential\"\n            };\n\n            // EXIF 2.3 Spec\n            var IFD1Tags = EXIF.IFD1Tags = {\n                0x0100: \"ImageWidth\",\n                0x0101: \"ImageHeight\",\n                0x0102: \"BitsPerSample\",\n                0x0103: \"Compression\",\n                0x0106: \"PhotometricInterpretation\",\n                0x0111: \"StripOffsets\",\n                0x0112: \"Orientation\",\n                0x0115: \"SamplesPerPixel\",\n                0x0116: \"RowsPerStrip\",\n                0x0117: \"StripByteCounts\",\n                0x011A: \"XResolution\",\n                0x011B: \"YResolution\",\n                0x011C: \"PlanarConfiguration\",\n                0x0128: \"ResolutionUnit\",\n                0x0201: \"JpegIFOffset\", // When image format is JPEG, this value show offset to JPEG data stored.(aka \"ThumbnailOffset\" or \"JPEGInterchangeFormat\")\n                0x0202: \"JpegIFByteCount\", // When image format is JPEG, this value shows data size of JPEG image (aka \"ThumbnailLength\" or \"JPEGInterchangeFormatLength\")\n                0x0211: \"YCbCrCoefficients\",\n                0x0212: \"YCbCrSubSampling\",\n                0x0213: \"YCbCrPositioning\",\n                0x0214: \"ReferenceBlackWhite\"\n            };\n\n            var StringValues = EXIF.StringValues = {\n                ExposureProgram: {\n                    0: \"Not defined\",\n                    1: \"Manual\",\n                    2: \"Normal program\",\n                    3: \"Aperture priority\",\n                    4: \"Shutter priority\",\n                    5: \"Creative program\",\n                    6: \"Action program\",\n                    7: \"Portrait mode\",\n                    8: \"Landscape mode\"\n                },\n                MeteringMode: {\n                    0: \"Unknown\",\n                    1: \"Average\",\n                    2: \"CenterWeightedAverage\",\n                    3: \"Spot\",\n                    4: \"MultiSpot\",\n                    5: \"Pattern\",\n                    6: \"Partial\",\n                    255: \"Other\"\n                },\n                LightSource: {\n                    0: \"Unknown\",\n                    1: \"Daylight\",\n                    2: \"Fluorescent\",\n                    3: \"Tungsten (incandescent light)\",\n                    4: \"Flash\",\n                    9: \"Fine weather\",\n                    10: \"Cloudy weather\",\n                    11: \"Shade\",\n                    12: \"Daylight fluorescent (D 5700 - 7100K)\",\n                    13: \"Day white fluorescent (N 4600 - 5400K)\",\n                    14: \"Cool white fluorescent (W 3900 - 4500K)\",\n                    15: \"White fluorescent (WW 3200 - 3700K)\",\n                    17: \"Standard light A\",\n                    18: \"Standard light B\",\n                    19: \"Standard light C\",\n                    20: \"D55\",\n                    21: \"D65\",\n                    22: \"D75\",\n                    23: \"D50\",\n                    24: \"ISO studio tungsten\",\n                    255: \"Other\"\n                },\n                Flash: {\n                    0x0000: \"Flash did not fire\",\n                    0x0001: \"Flash fired\",\n                    0x0005: \"Strobe return light not detected\",\n                    0x0007: \"Strobe return light detected\",\n                    0x0009: \"Flash fired, compulsory flash mode\",\n                    0x000D: \"Flash fired, compulsory flash mode, return light not detected\",\n                    0x000F: \"Flash fired, compulsory flash mode, return light detected\",\n                    0x0010: \"Flash did not fire, compulsory flash mode\",\n                    0x0018: \"Flash did not fire, auto mode\",\n                    0x0019: \"Flash fired, auto mode\",\n                    0x001D: \"Flash fired, auto mode, return light not detected\",\n                    0x001F: \"Flash fired, auto mode, return light detected\",\n                    0x0020: \"No flash function\",\n                    0x0041: \"Flash fired, red-eye reduction mode\",\n                    0x0045: \"Flash fired, red-eye reduction mode, return light not detected\",\n                    0x0047: \"Flash fired, red-eye reduction mode, return light detected\",\n                    0x0049: \"Flash fired, compulsory flash mode, red-eye reduction mode\",\n                    0x004D: \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\n                    0x004F: \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\n                    0x0059: \"Flash fired, auto mode, red-eye reduction mode\",\n                    0x005D: \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\n                    0x005F: \"Flash fired, auto mode, return light detected, red-eye reduction mode\"\n                },\n                SensingMethod: {\n                    1: \"Not defined\",\n                    2: \"One-chip color area sensor\",\n                    3: \"Two-chip color area sensor\",\n                    4: \"Three-chip color area sensor\",\n                    5: \"Color sequential area sensor\",\n                    7: \"Trilinear sensor\",\n                    8: \"Color sequential linear sensor\"\n                },\n                SceneCaptureType: {\n                    0: \"Standard\",\n                    1: \"Landscape\",\n                    2: \"Portrait\",\n                    3: \"Night scene\"\n                },\n                SceneType: {\n                    1: \"Directly photographed\"\n                },\n                CustomRendered: {\n                    0: \"Normal process\",\n                    1: \"Custom process\"\n                },\n                WhiteBalance: {\n                    0: \"Auto white balance\",\n                    1: \"Manual white balance\"\n                },\n                GainControl: {\n                    0: \"None\",\n                    1: \"Low gain up\",\n                    2: \"High gain up\",\n                    3: \"Low gain down\",\n                    4: \"High gain down\"\n                },\n                Contrast: {\n                    0: \"Normal\",\n                    1: \"Soft\",\n                    2: \"Hard\"\n                },\n                Saturation: {\n                    0: \"Normal\",\n                    1: \"Low saturation\",\n                    2: \"High saturation\"\n                },\n                Sharpness: {\n                    0: \"Normal\",\n                    1: \"Soft\",\n                    2: \"Hard\"\n                },\n                SubjectDistanceRange: {\n                    0: \"Unknown\",\n                    1: \"Macro\",\n                    2: \"Close view\",\n                    3: \"Distant view\"\n                },\n                FileSource: {\n                    3: \"DSC\"\n                },\n\n                Components: {\n                    0: \"\",\n                    1: \"Y\",\n                    2: \"Cb\",\n                    3: \"Cr\",\n                    4: \"R\",\n                    5: \"G\",\n                    6: \"B\"\n                }\n            };\n\n            function addEvent(element, event, handler) {\n                if (element.addEventListener) {\n                    element.addEventListener(event, handler, false);\n                } else if (element.attachEvent) {\n                    element.attachEvent(\"on\" + event, handler);\n                }\n            }\n\n            function imageHasData(img) {\n                return !!img.exifdata;\n            }\n\n            function base64ToArrayBuffer(base64, contentType) {\n                contentType = contentType || base64.match(/^data\\:([^\\;]+)\\;base64,/mi)[1] || ''; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'\n                base64 = base64.replace(/^data\\:([^\\;]+)\\;base64,/gmi, '');\n                var binary = atob(base64);\n                var len = binary.length;\n                var buffer = new ArrayBuffer(len);\n                var view = new Uint8Array(buffer);\n                for (var i = 0; i < len; i++) {\n                    view[i] = binary.charCodeAt(i);\n                }\n                return buffer;\n            }\n\n            function objectURLToBlob(url, callback) {\n                var http = new XMLHttpRequest();\n                http.open(\"GET\", url, true);\n                http.responseType = \"blob\";\n                http.onload = function (e) {\n                    if (this.status == 200 || this.status === 0) {\n                        callback(this.response);\n                    }\n                };\n                http.send();\n            }\n\n            function getImageData(img, callback) {\n                function handleBinaryFile(binFile) {\n                    var data = findEXIFinJPEG(binFile);\n                    img.exifdata = data || {};\n                    var iptcdata = findIPTCinJPEG(binFile);\n                    img.iptcdata = iptcdata || {};\n                    if (EXIF.isXmpEnabled) {\n                        var xmpdata = findXMPinJPEG(binFile);\n                        img.xmpdata = xmpdata || {};\n                    }\n                    if (callback) {\n                        callback.call(img);\n                    }\n                }\n\n                if (img.src) {\n                    if (/^data\\:/i.test(img.src)) {\n                        // Data URI\n                        var arrayBuffer = base64ToArrayBuffer(img.src);\n                        handleBinaryFile(arrayBuffer);\n                    } else if (/^blob\\:/i.test(img.src)) {\n                        // Object URL\n                        var fileReader = new FileReader();\n                        fileReader.onload = function (e) {\n                            handleBinaryFile(e.target.result);\n                        };\n                        objectURLToBlob(img.src, function (blob) {\n                            fileReader.readAsArrayBuffer(blob);\n                        });\n                    } else {\n                        var http = new XMLHttpRequest();\n                        http.onload = function () {\n                            if (this.status == 200 || this.status === 0) {\n                                handleBinaryFile(http.response);\n                            } else {\n                                throw \"Could not load image\";\n                            }\n                            http = null;\n                        };\n                        http.open(\"GET\", img.src, true);\n                        http.responseType = \"arraybuffer\";\n                        http.send(null);\n                    }\n                } else if (self.FileReader && (img instanceof self.Blob || img instanceof self.File)) {\n                    var fileReader = new FileReader();\n                    fileReader.onload = function (e) {\n                        if (debug) console.log(\"Got file of length \" + e.target.result.byteLength);\n                        handleBinaryFile(e.target.result);\n                    };\n\n                    fileReader.readAsArrayBuffer(img);\n                }\n            }\n\n            function findEXIFinJPEG(file) {\n                var dataView = new DataView(file);\n\n                if (debug) console.log(\"Got file of length \" + file.byteLength);\n                if (dataView.getUint8(0) != 0xFF || dataView.getUint8(1) != 0xD8) {\n                    if (debug) console.log(\"Not a valid JPEG\");\n                    return false; // not a valid jpeg\n                }\n\n                var offset = 2,\n                    length = file.byteLength,\n                    marker;\n\n                while (offset < length) {\n                    if (dataView.getUint8(offset) != 0xFF) {\n                        if (debug) console.log(\"Not a valid marker at offset \" + offset + \", found: \" + dataView.getUint8(offset));\n                        return false; // not a valid marker, something is wrong\n                    }\n\n                    marker = dataView.getUint8(offset + 1);\n                    if (debug) console.log(marker);\n\n                    // we could implement handling for other markers here,\n                    // but we're only looking for 0xFFE1 for EXIF data\n\n                    if (marker == 225) {\n                        if (debug) console.log(\"Found 0xFFE1 marker\");\n\n                        return readEXIFData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2);\n\n                        // offset += 2 + file.getShortAt(offset+2, true);\n                    } else {\n                        offset += 2 + dataView.getUint16(offset + 2);\n                    }\n                }\n            }\n\n            function findIPTCinJPEG(file) {\n                var dataView = new DataView(file);\n\n                if (debug) console.log(\"Got file of length \" + file.byteLength);\n                if (dataView.getUint8(0) != 0xFF || dataView.getUint8(1) != 0xD8) {\n                    if (debug) console.log(\"Not a valid JPEG\");\n                    return false; // not a valid jpeg\n                }\n\n                var offset = 2,\n                    length = file.byteLength;\n\n                var isFieldSegmentStart = function isFieldSegmentStart(dataView, offset) {\n                    return dataView.getUint8(offset) === 0x38 && dataView.getUint8(offset + 1) === 0x42 && dataView.getUint8(offset + 2) === 0x49 && dataView.getUint8(offset + 3) === 0x4D && dataView.getUint8(offset + 4) === 0x04 && dataView.getUint8(offset + 5) === 0x04;\n                };\n\n                while (offset < length) {\n\n                    if (isFieldSegmentStart(dataView, offset)) {\n\n                        // Get the length of the name header (which is padded to an even number of bytes)\n                        var nameHeaderLength = dataView.getUint8(offset + 7);\n                        if (nameHeaderLength % 2 !== 0) nameHeaderLength += 1;\n                        // Check for pre photoshop 6 format\n                        if (nameHeaderLength === 0) {\n                            // Always 4\n                            nameHeaderLength = 4;\n                        }\n\n                        var startOffset = offset + 8 + nameHeaderLength;\n                        var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\n\n                        return readIPTCData(file, startOffset, sectionLength);\n\n                        break;\n                    }\n\n                    // Not the marker, continue searching\n                    offset++;\n                }\n            }\n            var IptcFieldMap = {\n                0x78: 'caption',\n                0x6E: 'credit',\n                0x19: 'keywords',\n                0x37: 'dateCreated',\n                0x50: 'byline',\n                0x55: 'bylineTitle',\n                0x7A: 'captionWriter',\n                0x69: 'headline',\n                0x74: 'copyright',\n                0x0F: 'category'\n            };\n            function readIPTCData(file, startOffset, sectionLength) {\n                var dataView = new DataView(file);\n                var data = {};\n                var fieldValue, fieldName, dataSize, segmentType, segmentSize;\n                var segmentStartPos = startOffset;\n                while (segmentStartPos < startOffset + sectionLength) {\n                    if (dataView.getUint8(segmentStartPos) === 0x1C && dataView.getUint8(segmentStartPos + 1) === 0x02) {\n                        segmentType = dataView.getUint8(segmentStartPos + 2);\n                        if (segmentType in IptcFieldMap) {\n                            dataSize = dataView.getInt16(segmentStartPos + 3);\n                            segmentSize = dataSize + 5;\n                            fieldName = IptcFieldMap[segmentType];\n                            fieldValue = getStringFromDB(dataView, segmentStartPos + 5, dataSize);\n                            // Check if we already stored a value with this name\n                            if (data.hasOwnProperty(fieldName)) {\n                                // Value already stored with this name, create multivalue field\n                                if (data[fieldName] instanceof Array) {\n                                    data[fieldName].push(fieldValue);\n                                } else {\n                                    data[fieldName] = [data[fieldName], fieldValue];\n                                }\n                            } else {\n                                data[fieldName] = fieldValue;\n                            }\n                        }\n                    }\n                    segmentStartPos++;\n                }\n                return data;\n            }\n\n            function readTags(file, tiffStart, dirStart, strings, bigEnd) {\n                var entries = file.getUint16(dirStart, !bigEnd),\n                    tags = {},\n                    entryOffset,\n                    tag,\n                    i;\n\n                for (i = 0; i < entries; i++) {\n                    entryOffset = dirStart + i * 12 + 2;\n                    tag = strings[file.getUint16(entryOffset, !bigEnd)];\n                    if (!tag && debug) console.log(\"Unknown tag: \" + file.getUint16(entryOffset, !bigEnd));\n                    tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\n                }\n                return tags;\n            }\n\n            function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {\n                var type = file.getUint16(entryOffset + 2, !bigEnd),\n                    numValues = file.getUint32(entryOffset + 4, !bigEnd),\n                    valueOffset = file.getUint32(entryOffset + 8, !bigEnd) + tiffStart,\n                    offset,\n                    vals,\n                    val,\n                    n,\n                    numerator,\n                    denominator;\n\n                switch (type) {\n                    case 1: // byte, 8-bit unsigned int\n                    case 7:\n                        // undefined, 8-bit byte, value depending on field\n                        if (numValues == 1) {\n                            return file.getUint8(entryOffset + 8, !bigEnd);\n                        } else {\n                            offset = numValues > 4 ? valueOffset : entryOffset + 8;\n                            vals = [];\n                            for (n = 0; n < numValues; n++) {\n                                vals[n] = file.getUint8(offset + n);\n                            }\n                            return vals;\n                        }\n\n                    case 2:\n                        // ascii, 8-bit byte\n                        offset = numValues > 4 ? valueOffset : entryOffset + 8;\n                        return getStringFromDB(file, offset, numValues - 1);\n\n                    case 3:\n                        // short, 16 bit int\n                        if (numValues == 1) {\n                            return file.getUint16(entryOffset + 8, !bigEnd);\n                        } else {\n                            offset = numValues > 2 ? valueOffset : entryOffset + 8;\n                            vals = [];\n                            for (n = 0; n < numValues; n++) {\n                                vals[n] = file.getUint16(offset + 2 * n, !bigEnd);\n                            }\n                            return vals;\n                        }\n\n                    case 4:\n                        // long, 32 bit int\n                        if (numValues == 1) {\n                            return file.getUint32(entryOffset + 8, !bigEnd);\n                        } else {\n                            vals = [];\n                            for (n = 0; n < numValues; n++) {\n                                vals[n] = file.getUint32(valueOffset + 4 * n, !bigEnd);\n                            }\n                            return vals;\n                        }\n\n                    case 5:\n                        // rational = two long values, first is numerator, second is denominator\n                        if (numValues == 1) {\n                            numerator = file.getUint32(valueOffset, !bigEnd);\n                            denominator = file.getUint32(valueOffset + 4, !bigEnd);\n                            val = new Number(numerator / denominator);\n                            val.numerator = numerator;\n                            val.denominator = denominator;\n                            return val;\n                        } else {\n                            vals = [];\n                            for (n = 0; n < numValues; n++) {\n                                numerator = file.getUint32(valueOffset + 8 * n, !bigEnd);\n                                denominator = file.getUint32(valueOffset + 4 + 8 * n, !bigEnd);\n                                vals[n] = new Number(numerator / denominator);\n                                vals[n].numerator = numerator;\n                                vals[n].denominator = denominator;\n                            }\n                            return vals;\n                        }\n\n                    case 9:\n                        // slong, 32 bit signed int\n                        if (numValues == 1) {\n                            return file.getInt32(entryOffset + 8, !bigEnd);\n                        } else {\n                            vals = [];\n                            for (n = 0; n < numValues; n++) {\n                                vals[n] = file.getInt32(valueOffset + 4 * n, !bigEnd);\n                            }\n                            return vals;\n                        }\n\n                    case 10:\n                        // signed rational, two slongs, first is numerator, second is denominator\n                        if (numValues == 1) {\n                            return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset + 4, !bigEnd);\n                        } else {\n                            vals = [];\n                            for (n = 0; n < numValues; n++) {\n                                vals[n] = file.getInt32(valueOffset + 8 * n, !bigEnd) / file.getInt32(valueOffset + 4 + 8 * n, !bigEnd);\n                            }\n                            return vals;\n                        }\n                }\n            }\n\n            /**\n            * Given an IFD (Image File Directory) start offset\n            * returns an offset to next IFD or 0 if it's the last IFD.\n            */\n            function getNextIFDOffset(dataView, dirStart, bigEnd) {\n                //the first 2bytes means the number of directory entries contains in this IFD\n                var entries = dataView.getUint16(dirStart, !bigEnd);\n\n                // After last directory entry, there is a 4bytes of data,\n                // it means an offset to next IFD.\n                // If its value is '0x00000000', it means this is the last IFD and there is no linked IFD.\n\n                return dataView.getUint32(dirStart + 2 + entries * 12, !bigEnd); // each entry is 12 bytes long\n            }\n\n            function readThumbnailImage(dataView, tiffStart, firstIFDOffset, bigEnd) {\n                // get the IFD1 offset\n                var IFD1OffsetPointer = getNextIFDOffset(dataView, tiffStart + firstIFDOffset, bigEnd);\n\n                if (!IFD1OffsetPointer) {\n                    // console.log('******** IFD1Offset is empty, image thumb not found ********');\n                    return {};\n                } else if (IFD1OffsetPointer > dataView.byteLength) {\n                    // this should not happen\n                    // console.log('******** IFD1Offset is outside the bounds of the DataView ********');\n                    return {};\n                }\n                // console.log('*******  thumbnail IFD offset (IFD1) is: %s', IFD1OffsetPointer);\n\n                var thumbTags = readTags(dataView, tiffStart, tiffStart + IFD1OffsetPointer, IFD1Tags, bigEnd);\n\n                // EXIF 2.3 specification for JPEG format thumbnail\n\n                // If the value of Compression(0x0103) Tag in IFD1 is '6', thumbnail image format is JPEG.\n                // Most of Exif image uses JPEG format for thumbnail. In that case, you can get offset of thumbnail\n                // by JpegIFOffset(0x0201) Tag in IFD1, size of thumbnail by JpegIFByteCount(0x0202) Tag.\n                // Data format is ordinary JPEG format, starts from 0xFFD8 and ends by 0xFFD9. It seems that\n                // JPEG format and 160x120pixels of size are recommended thumbnail format for Exif2.1 or later.\n\n                if (thumbTags['Compression']) {\n                    // console.log('Thumbnail image found!');\n\n                    switch (thumbTags['Compression']) {\n                        case 6:\n                            // console.log('Thumbnail image format is JPEG');\n                            if (thumbTags.JpegIFOffset && thumbTags.JpegIFByteCount) {\n                                // extract the thumbnail\n                                var tOffset = tiffStart + thumbTags.JpegIFOffset;\n                                var tLength = thumbTags.JpegIFByteCount;\n                                thumbTags['blob'] = new Blob([new Uint8Array(dataView.buffer, tOffset, tLength)], {\n                                    type: 'image/jpeg'\n                                });\n                            }\n                            break;\n\n                        case 1:\n                            console.log(\"Thumbnail image format is TIFF, which is not implemented.\");\n                            break;\n                        default:\n                            console.log(\"Unknown thumbnail image format '%s'\", thumbTags['Compression']);\n                    }\n                } else if (thumbTags['PhotometricInterpretation'] == 2) {\n                    console.log(\"Thumbnail image format is RGB, which is not implemented.\");\n                }\n                return thumbTags;\n            }\n\n            function getStringFromDB(buffer, start, length) {\n                var outstr = \"\";\n                for (n = start; n < start + length; n++) {\n                    outstr += String.fromCharCode(buffer.getUint8(n));\n                }\n                return outstr;\n            }\n\n            function readEXIFData(file, start) {\n                if (getStringFromDB(file, start, 4) != \"Exif\") {\n                    if (debug) console.log(\"Not valid EXIF data! \" + getStringFromDB(file, start, 4));\n                    return false;\n                }\n\n                var bigEnd,\n                    tags,\n                    tag,\n                    exifData,\n                    gpsData,\n                    tiffOffset = start + 6;\n\n                // test for TIFF validity and endianness\n                if (file.getUint16(tiffOffset) == 0x4949) {\n                    bigEnd = false;\n                } else if (file.getUint16(tiffOffset) == 0x4D4D) {\n                    bigEnd = true;\n                } else {\n                    if (debug) console.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\");\n                    return false;\n                }\n\n                if (file.getUint16(tiffOffset + 2, !bigEnd) != 0x002A) {\n                    if (debug) console.log(\"Not valid TIFF data! (no 0x002A)\");\n                    return false;\n                }\n\n                var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);\n\n                if (firstIFDOffset < 0x00000008) {\n                    if (debug) console.log(\"Not valid TIFF data! (First offset less than 8)\", file.getUint32(tiffOffset + 4, !bigEnd));\n                    return false;\n                }\n\n                tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);\n\n                if (tags.ExifIFDPointer) {\n                    exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);\n                    for (tag in exifData) {\n                        switch (tag) {\n                            case \"LightSource\":\n                            case \"Flash\":\n                            case \"MeteringMode\":\n                            case \"ExposureProgram\":\n                            case \"SensingMethod\":\n                            case \"SceneCaptureType\":\n                            case \"SceneType\":\n                            case \"CustomRendered\":\n                            case \"WhiteBalance\":\n                            case \"GainControl\":\n                            case \"Contrast\":\n                            case \"Saturation\":\n                            case \"Sharpness\":\n                            case \"SubjectDistanceRange\":\n                            case \"FileSource\":\n                                exifData[tag] = StringValues[tag][exifData[tag]];\n                                break;\n\n                            case \"ExifVersion\":\n                            case \"FlashpixVersion\":\n                                exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);\n                                break;\n\n                            case \"ComponentsConfiguration\":\n                                exifData[tag] = StringValues.Components[exifData[tag][0]] + StringValues.Components[exifData[tag][1]] + StringValues.Components[exifData[tag][2]] + StringValues.Components[exifData[tag][3]];\n                                break;\n                        }\n                        tags[tag] = exifData[tag];\n                    }\n                }\n\n                if (tags.GPSInfoIFDPointer) {\n                    gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);\n                    for (tag in gpsData) {\n                        switch (tag) {\n                            case \"GPSVersionID\":\n                                gpsData[tag] = gpsData[tag][0] + \".\" + gpsData[tag][1] + \".\" + gpsData[tag][2] + \".\" + gpsData[tag][3];\n                                break;\n                        }\n                        tags[tag] = gpsData[tag];\n                    }\n                }\n\n                // extract thumbnail\n                tags['thumbnail'] = readThumbnailImage(file, tiffOffset, firstIFDOffset, bigEnd);\n\n                return tags;\n            }\n\n            function findXMPinJPEG(file) {\n\n                if (!('DOMParser' in self)) {\n                    // console.warn('XML parsing not supported without DOMParser');\n                    return;\n                }\n                var dataView = new DataView(file);\n\n                if (debug) console.log(\"Got file of length \" + file.byteLength);\n                if (dataView.getUint8(0) != 0xFF || dataView.getUint8(1) != 0xD8) {\n                    if (debug) console.log(\"Not a valid JPEG\");\n                    return false; // not a valid jpeg\n                }\n\n                var offset = 2,\n                    length = file.byteLength,\n                    dom = new DOMParser();\n\n                while (offset < length - 4) {\n                    if (getStringFromDB(dataView, offset, 4) == \"http\") {\n                        var startOffset = offset - 1;\n                        var sectionLength = dataView.getUint16(offset - 2) - 1;\n                        var xmpString = getStringFromDB(dataView, startOffset, sectionLength);\n                        var xmpEndIndex = xmpString.indexOf('xmpmeta>') + 8;\n                        xmpString = xmpString.substring(xmpString.indexOf('<x:xmpmeta'), xmpEndIndex);\n\n                        var indexOfXmp = xmpString.indexOf('x:xmpmeta') + 10;\n                        //Many custom written programs embed xmp/xml without any namespace. Following are some of them.\n                        //Without these namespaces, XML is thought to be invalid by parsers\n                        xmpString = xmpString.slice(0, indexOfXmp) + 'xmlns:Iptc4xmpCore=\"http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/\" ' + 'xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ' + 'xmlns:tiff=\"http://ns.adobe.com/tiff/1.0/\" ' + 'xmlns:plus=\"http://schemas.android.com/apk/lib/com.google.android.gms.plus\" ' + 'xmlns:ext=\"http://www.gettyimages.com/xsltExtension/1.0\" ' + 'xmlns:exif=\"http://ns.adobe.com/exif/1.0/\" ' + 'xmlns:stEvt=\"http://ns.adobe.com/xap/1.0/sType/ResourceEvent#\" ' + 'xmlns:stRef=\"http://ns.adobe.com/xap/1.0/sType/ResourceRef#\" ' + 'xmlns:crs=\"http://ns.adobe.com/camera-raw-settings/1.0/\" ' + 'xmlns:xapGImg=\"http://ns.adobe.com/xap/1.0/g/img/\" ' + 'xmlns:Iptc4xmpExt=\"http://iptc.org/std/Iptc4xmpExt/2008-02-29/\" ' + xmpString.slice(indexOfXmp);\n\n                        var domDocument = dom.parseFromString(xmpString, 'text/xml');\n                        return xml2Object(domDocument);\n                    } else {\n                        offset++;\n                    }\n                }\n            }\n\n            function xml2json(xml) {\n                var json = {};\n\n                if (xml.nodeType == 1) {\n                    // element node\n                    if (xml.attributes.length > 0) {\n                        json['@attributes'] = {};\n                        for (var j = 0; j < xml.attributes.length; j++) {\n                            var attribute = xml.attributes.item(j);\n                            json['@attributes'][attribute.nodeName] = attribute.nodeValue;\n                        }\n                    }\n                } else if (xml.nodeType == 3) {\n                    // text node\n                    return xml.nodeValue;\n                }\n\n                // deal with children\n                if (xml.hasChildNodes()) {\n                    for (var i = 0; i < xml.childNodes.length; i++) {\n                        var child = xml.childNodes.item(i);\n                        var nodeName = child.nodeName;\n                        if (json[nodeName] == null) {\n                            json[nodeName] = xml2json(child);\n                        } else {\n                            if (json[nodeName].push == null) {\n                                var old = json[nodeName];\n                                json[nodeName] = [];\n                                json[nodeName].push(old);\n                            }\n                            json[nodeName].push(xml2json(child));\n                        }\n                    }\n                }\n\n                return json;\n            }\n\n            function xml2Object(xml) {\n                try {\n                    var obj = {};\n                    if (xml.children.length > 0) {\n                        for (var i = 0; i < xml.children.length; i++) {\n                            var item = xml.children.item(i);\n                            var attributes = item.attributes;\n                            for (var idx in attributes) {\n                                var itemAtt = attributes[idx];\n                                var dataKey = itemAtt.nodeName;\n                                var dataValue = itemAtt.nodeValue;\n\n                                if (dataKey !== undefined) {\n                                    obj[dataKey] = dataValue;\n                                }\n                            }\n                            var nodeName = item.nodeName;\n\n                            if (typeof obj[nodeName] == \"undefined\") {\n                                obj[nodeName] = xml2json(item);\n                            } else {\n                                if (typeof obj[nodeName].push == \"undefined\") {\n                                    var old = obj[nodeName];\n\n                                    obj[nodeName] = [];\n                                    obj[nodeName].push(old);\n                                }\n                                obj[nodeName].push(xml2json(item));\n                            }\n                        }\n                    } else {\n                        obj = xml.textContent;\n                    }\n                    return obj;\n                } catch (e) {\n                    console.log(e.message);\n                }\n            }\n\n            EXIF.enableXmp = function () {\n                EXIF.isXmpEnabled = true;\n            };\n\n            EXIF.disableXmp = function () {\n                EXIF.isXmpEnabled = false;\n            };\n\n            EXIF.getData = function (img, callback) {\n                if ((self.Image && img instanceof self.Image || self.HTMLImageElement && img instanceof self.HTMLImageElement) && !img.complete) return false;\n\n                if (!imageHasData(img)) {\n                    getImageData(img, callback);\n                } else {\n                    if (callback) {\n                        callback.call(img);\n                    }\n                }\n                return true;\n            };\n\n            EXIF.getTag = function (img, tag) {\n                if (!imageHasData(img)) return;\n                return img.exifdata[tag];\n            };\n\n            EXIF.getIptcTag = function (img, tag) {\n                if (!imageHasData(img)) return;\n                return img.iptcdata[tag];\n            };\n\n            EXIF.getAllTags = function (img) {\n                if (!imageHasData(img)) return {};\n                var a,\n                    data = img.exifdata,\n                    tags = {};\n                for (a in data) {\n                    if (data.hasOwnProperty(a)) {\n                        tags[a] = data[a];\n                    }\n                }\n                return tags;\n            };\n\n            EXIF.getAllIptcTags = function (img) {\n                if (!imageHasData(img)) return {};\n                var a,\n                    data = img.iptcdata,\n                    tags = {};\n                for (a in data) {\n                    if (data.hasOwnProperty(a)) {\n                        tags[a] = data[a];\n                    }\n                }\n                return tags;\n            };\n\n            EXIF.pretty = function (img) {\n                if (!imageHasData(img)) return \"\";\n                var a,\n                    data = img.exifdata,\n                    strPretty = \"\";\n                for (a in data) {\n                    if (data.hasOwnProperty(a)) {\n                        if (_typeof(data[a]) == \"object\") {\n                            if (data[a] instanceof Number) {\n                                strPretty += a + \" : \" + data[a] + \" [\" + data[a].numerator + \"/\" + data[a].denominator + \"]\\r\\n\";\n                            } else {\n                                strPretty += a + \" : [\" + data[a].length + \" values]\\r\\n\";\n                            }\n                        } else {\n                            strPretty += a + \" : \" + data[a] + \"\\r\\n\";\n                        }\n                    }\n                }\n                return strPretty;\n            };\n\n            EXIF.readFromBinaryFile = function (file) {\n                return findEXIFinJPEG(file);\n            };\n\n            if (typeof define === 'function' && define.amd) {\n                define('exif-js', [], function () {\n                    return EXIF;\n                });\n            }\n        }).call(this);\n    }, {}], 2: [function (require, module, exports) {\n        var EXIF = require('exif-js');\n\n        function _getFileOrientation(file, callback) {\n            var orientation = null;\n            EXIF.getData(file, function () {\n                EXIF.getAllTags(this);\n                orientation = EXIF.getTag(this, 'Orientation');\n                callback(orientation);\n            });\n        }\n\n        function _rotateImage(img, direction, canvas) {\n            // Minimum / maximum rotate times\n            var min_step = 0;\n            var max_step = 3;\n            if (img == null) return;\n\n            var height = img.height;\n            var width = img.width;\n\n            var step = 2;\n            if (step == null) {\n                step = min_step;\n            }\n\n            if (direction == 'right') {\n                step++;\n                step > max_step && (step = min_step);\n            } else {\n                step--;\n                step < min_step && (step = max_step);\n            }\n            var degree = step * 90 * Math.PI / 180;\n            var ctx = canvas.getContext('2d');\n            switch (step) {\n                case 0:\n                    canvas.width = width;\n                    canvas.height = height;\n                    ctx.drawImage(img, 0, 0);\n                    break;\n                case 1:\n                    canvas.width = height;\n                    canvas.height = width;\n                    ctx.rotate(degree);\n                    ctx.drawImage(img, 0, -height);\n                    break;\n                case 2:\n                    canvas.width = width;\n                    canvas.height = height;\n                    ctx.rotate(degree);\n                    ctx.drawImage(img, -width, -height);\n                    break;\n                case 3:\n                    canvas.width = height;\n                    canvas.height = width;\n                    ctx.rotate(degree);\n                    ctx.drawImage(img, -width, 0);\n                    break;\n            }\n        }\n\n        function iOSOrientationAutoFix(file, callback) {\n\n            _getFileOrientation(file, function (oritentation) {\n                var fr = new FileReader();\n                fr.readAsDataURL(file);\n\n                fr.addEventListener(\"load\", function () {\n                    var url = fr.result;\n                    var img = new Image();\n                    img.src = url;\n                    img.onload = function () {\n\n                        var canvas = document.createElement(\"canvas\");\n                        var ctx = canvas.getContext(\"2d\");\n                        canvas.width = img.width;\n                        canvas.height = img.height;\n                        ctx.drawImage(img, 0, 0, img.width, img.height);\n\n                        if (navigator.userAgent.match(/iphone/i)) {\n                            // We fix iphone\n                            if (oritentation != \"\" && oritentation != 1) {\n                                switch (oritentation) {\n                                    case 6:\n                                        _rotateImage(img, 'left', canvas);\n                                        break;\n                                    case 8:\n                                        _rotateImage(img, 'right', canvas);\n                                        break;\n                                    case 3:\n                                        _rotateImage(img, 'left', canvas);\n                                        _rotateImage(img, 'left', canvas);\n                                        break;\n                                }\n                            }\n                            callback(canvas.toDataURL());\n                        } else {\n                            callback(url);\n                        }\n                    };\n                });\n            });\n        }\n\n        module.exports = {\n            iOSOrientationAutoFix: iOSOrientationAutoFix\n        };\n\n        window.ImageUtility = module.exports;\n    }, { \"exif-js\": 1 }] }, {}, [2]);"]}