{"version":3,"sources":["Tool.js"],"names":["_slicedToArray","arr","i","Array","isArray","Symbol","iterator","Object","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","value","length","err","sliceIterator","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","Constructor","protoProps","staticProps","prototype","_defineProperty","obj","_classCallCheck","instance","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","e","t","n","r","s","o","u","a","require","f","Error","code","l","exports","1","module","_Symbol","SymbolTypes","AlphanumericSymbol","_Symbol2","x","y","width","height","this","getPrototypeOf","ALPHANUMERIC","./Symbol","./enums/SymbolTypes","2","_Symbol3","BracketTypes","BracketSymbol","_Symbol4","_this2","BRACKET","bracketType","CLOSE","indexOf","minX","maxX","OPEN","./enums/BracketTypes","3","RegionTypes","Expression","region_type","arguments","ROOT","region_name","wall","left","bottom","Infinity","right","top","symbols","symbol","func","regionCondFunc","condFunc","test","j","subSymbols","apply","region","./enums/RegionTypes","4","_Symbol5","FractionSymbol","_Symbol6","FRACTION","5","_Symbol7","LimitSymbol","_Symbol8","LIMIT","6","_Symbol9","OperatorSymbol","_Symbol10","OPERATOR","7","Constant","SymbolFactory","RecognitionTool","ls","type","newWall","getWallCopy","st","start","overlap","index","isInRegion","marked","minY","maxY","leftMostIndex","limitIndex","overlapIndex","upperThreshold","lowerThreshold","maxLength","stop","mainLine","Fraction","element","eqns","svgCanvas","getSelectedElems","slice","document","querySelectorAll","make","sort","b","result","temp1","temp2","parent","relation","expression","stack","queue","setWall","_queue$shift","shift","_queue$shift2","hor","oldWall","pop","_stack$pop","_stack$pop2","si","SYMBOL_TYPES","region_walls","ABOVE","BELOW","SUPER","SUBSC","TLEFT","BLEFT","CONTAINS","regions","bst","parse","getTex","replace","TEX_TEXT","hasAnyBottom","hasAnyTop","hasElement","BRACKET_TYPES","./Expression","./SymbolFactory","./constant","8","_Symbol12","RootSymbol","_Symbol13","9","_Symbol14","size","10","elem","textContent","tagName","rect","svgedit","utilities","getBBox","nodeName","id","split","LINE","./AlphanumericSymbol","./BracketSymbol","./FractionSymbol","./LimitSymbol","./OperatorSymbol","./RootSymbol","11","window","Tool","./RecognitionTool","12","_TEX_TEXT","REGION_NAMES","SUPERS","SUSC","TEXT","sum","lim","∑","fraction","root","integral","∫","lbracket","rbracket","(",")","±","∓","+","×","—","overline","underline","<","≤",">","≥","=","→","13","14","15"],"mappings":"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","file":"Tool.js","sourcesContent":["\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n(function () {\n    function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = typeof require == \"function\" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error(\"Cannot find module '\" + o + \"'\");throw f.code = \"MODULE_NOT_FOUND\", f;\n                }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {\n                    var n = t[o][1][e];return s(n ? n : e);\n                }, l, l.exports, e, t, n, r);\n            }return n[o].exports;\n        }var i = typeof require == \"function\" && require;for (var o = 0; o < r.length; o++) {\n            s(r[o]);\n        }return s;\n    }return e;\n})()({ 1: [function (require, module, exports) {\n        var _Symbol = require('./Symbol');\n        var SymbolTypes = require('./enums/SymbolTypes');\n\n        var AlphanumericSymbol = function (_Symbol2) {\n            _inherits(AlphanumericSymbol, _Symbol2);\n\n            /**\r\n             * Construct AlphanumericSymbol instance.\r\n             * @param x\r\n             * @param y\r\n             * @param width\r\n             * @param height\r\n             * @param value\r\n             */\n            function AlphanumericSymbol(x, y, width, height, value) {\n                _classCallCheck(this, AlphanumericSymbol);\n\n                return _possibleConstructorReturn(this, (AlphanumericSymbol.__proto__ || Object.getPrototypeOf(AlphanumericSymbol)).call(this, x, y, width, height, value, SymbolTypes.ALPHANUMERIC));\n            }\n\n            return AlphanumericSymbol;\n        }(_Symbol);\n\n        module.exports = AlphanumericSymbol;\n    }, { \"./Symbol\": 9, \"./enums/SymbolTypes\": 15 }], 2: [function (require, module, exports) {\n        var _Symbol3 = require('./Symbol');\n        var SymbolTypes = require('./enums/SymbolTypes');\n        var BracketTypes = require('./enums/BracketTypes');\n\n        var BracketSymbol = function (_Symbol4) {\n            _inherits(BracketSymbol, _Symbol4);\n\n            /**\r\n             * Construct BracketSymbol instance.\r\n             * @param x\r\n             * @param y\r\n             * @param width\r\n             * @param height\r\n             * @param value\r\n             */\n            function BracketSymbol(x, y, width, height, value) {\n                _classCallCheck(this, BracketSymbol);\n\n                var _this2 = _possibleConstructorReturn(this, (BracketSymbol.__proto__ || Object.getPrototypeOf(BracketSymbol)).call(this, x, y, width, height, value, SymbolTypes.BRACKET));\n\n                _this2.bracketType = BracketTypes.CLOSE;\n                var BRACKET = [\"lbracket\", \"(\", \")\", \"rbracket\"]; // organization needed\n                if (BRACKET.indexOf(value) < BRACKET.length / 2) {\n                    _this2.minX -= width;\n                    _this2.maxX -= width;\n                    _this2.x -= width;\n                    _this2.bracketType = BracketTypes.OPEN;\n                }\n                return _this2;\n            }\n\n            return BracketSymbol;\n        }(_Symbol3);\n\n        module.exports = BracketSymbol;\n    }, { \"./Symbol\": 9, \"./enums/BracketTypes\": 13, \"./enums/SymbolTypes\": 15 }], 3: [function (require, module, exports) {\n        var SymbolTypes = require('./enums/SymbolTypes');\n        var RegionTypes = require('./enums/RegionTypes');\n\n        var Expression = function () {\n\n            /**\r\n            * Construct the driver instance.\r\n            * @param region_type\r\n            */\n            function Expression() {\n                var region_type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RegionTypes.ROOT;\n\n                _classCallCheck(this, Expression);\n\n                this.region_type = region_type;\n                this.region_name = region_type; // alias\n                this.wall = {\n                    'left': 0,\n                    'bottom': Infinity,\n                    'right': Infinity,\n                    'top': 0 // maybe create a Wall class.\n\n                };this.symbols = [];\n            }\n\n            /**\r\n             * Add a new Symbol in this Expression.\r\n             * @param {Symbol} symbol\r\n             */\n\n\n            _createClass(Expression, [{\n                key: \"addSymbol\",\n                value: function addSymbol(symbol) {\n                    this.symbols.push(symbol);\n                }\n\n                /**\r\n                 * Set this.Wall with given parameters.\r\n                 * @param left this must be a wall if it is the only parameter\r\n                 * @param [top]\r\n                 * @param [right]\r\n                 * @param [bottom]\r\n                 */\n\n            }, {\n                key: \"setWall\",\n                value: function setWall(left, top, right, bottom) {\n                    if (left.left) {\n                        // given a wall\n                        this.wall = left;\n                        return;\n                    }\n                    if (left.length && left.length == 3) {\n                        this.wall.left = left[0][0];\n                        this.wall.bottom = left[0][1];\n                        this.wall.right = left[1][0];\n                        this.wall.top = left[1][1];\n                        return;\n                    }\n                    this.wall = {\n                        'left': left,\n                        'bottom': bottom,\n                        'right': right,\n                        'top': top\n                    };\n                }\n                /**\r\n                 * Returns true iff symbol has at 1 or more elements.\r\n                 * @returns {boolean}\r\n                 */\n\n            }, {\n                key: \"hasElement\",\n                value: function hasElement() {\n                    return this.symbols.length > 0;\n                }\n                /** This applys func if this passes regionCondFunc, and each symbol in each region passes condFunc\r\n                 * Also this can be improved, but it requires some function changes in svg editor\r\n                 * @param func\r\n                 * @param [regionCondFunc]\r\n                 * @param [condFunc]\r\n                */\n\n            }, {\n                key: \"apply\",\n                value: function apply(func, regionCondFunc, condFunc) {\n                    if (!condFunc) {\n                        condFunc = function condFunc() {\n                            return true;\n                        };\n                    }\n                    if (!regionCondFunc) {\n                        regionCondFunc = function regionCondFunc() {\n                            return true;\n                        };\n                    }\n\n                    for (var i = 0; i < this.symbols.length; i++) {\n                        if (this.symbols[i].value === \"lim\") {\n                            var test = false;\n                            for (var j = 0; j < this.symbols[i].subSymbols.length; j++) {\n                                if (condFunc(this.symbols[i].subSymbols[j])) {\n                                    func(this.symbols[i].subSymbols[j]);\n                                    this.symbols[i].subSymbols[j].apply(func, function (region) {\n                                        return true;\n                                    }, condFunc);\n                                    test = true;\n                                } else {\n                                    this.symbols[i].subSymbols[j].apply(func, regionCondFunc, condFunc);\n                                }\n                            }\n                            if (test) {\n                                this.symbols[i].apply(func, function (region) {\n                                    return true;\n                                }, condFunc);\n                            } else {\n                                this.symbols[i].apply(func, regionCondFunc, condFunc);\n                            }\n                        } else {\n                            if (condFunc(this.symbols[i])) {\n                                func(this.symbols[i]);\n                                this.symbols[i].apply(func, function (region) {\n                                    return true;\n                                }, condFunc);\n                            } else {\n                                this.symbols[i].apply(func, regionCondFunc, condFunc);\n                            }\n                        }\n                    }\n                }\n            }]);\n\n            return Expression;\n        }();\n\n        module.exports = Expression;\n    }, { \"./enums/RegionTypes\": 14, \"./enums/SymbolTypes\": 15 }], 4: [function (require, module, exports) {\n        var _Symbol5 = require('./Symbol');\n        var SymbolTypes = require('./enums/SymbolTypes');\n\n        var FractionSymbol = function (_Symbol6) {\n            _inherits(FractionSymbol, _Symbol6);\n\n            /**\r\n             * Construct FractionSymbol instance.\r\n               * @param x\r\n             * @param y\r\n             * @param width\r\n             * @param height\r\n             * @param value\r\n             */\n            function FractionSymbol(x, y, width, height, value) {\n                _classCallCheck(this, FractionSymbol);\n\n                return _possibleConstructorReturn(this, (FractionSymbol.__proto__ || Object.getPrototypeOf(FractionSymbol)).call(this, x, y, width, height, value, SymbolTypes.FRACTION));\n            }\n\n            return FractionSymbol;\n        }(_Symbol5);\n\n        module.exports = FractionSymbol;\n    }, { \"./Symbol\": 9, \"./enums/SymbolTypes\": 15 }], 5: [function (require, module, exports) {\n        var _Symbol7 = require('./Symbol');\n        var SymbolTypes = require('./enums/SymbolTypes');\n\n        var LimitSymbol = function (_Symbol8) {\n            _inherits(LimitSymbol, _Symbol8);\n\n            /**\r\n             * Construct LimitSymbol instance.\r\n             * might require name change to a line\r\n             * @param x\r\n             * @param y\r\n             * @param width\r\n             * @param height\r\n             * @param value\r\n             */\n            function LimitSymbol(x, y, width, height, value) {\n                _classCallCheck(this, LimitSymbol);\n\n                return _possibleConstructorReturn(this, (LimitSymbol.__proto__ || Object.getPrototypeOf(LimitSymbol)).call(this, x, y, width, height, value, SymbolTypes.LIMIT));\n            }\n\n            return LimitSymbol;\n        }(_Symbol7);\n\n        module.exports = LimitSymbol;\n\n        // function LimitSymbol(x, y, width, height, value) {\n        //     Symbol.apply(this, [x, y, width, height, value]);\n        //     //delete(this.region.contains);\n        //     this.type = SYMBOL_TYPES.LIMIT;\n        // }\n        // LimitSymbol.prototype = Object.create(Symbol.prototype);\n        // LimitSymbol.prototype.constructor = LimitSymbol;\n    }, { \"./Symbol\": 9, \"./enums/SymbolTypes\": 15 }], 6: [function (require, module, exports) {\n        var _Symbol9 = require('./Symbol');\n        var SymbolTypes = require('./enums/SymbolTypes');\n\n        var OperatorSymbol = function (_Symbol10) {\n            _inherits(OperatorSymbol, _Symbol10);\n\n            /**\r\n             * Construct OperatorSymbol instance.\r\n             * //might require name change to a line\r\n             * @param x\r\n             * @param y\r\n             * @param width\r\n             * @param height\r\n             * @param value\r\n             */\n            function OperatorSymbol(x, y, width, height, value) {\n                _classCallCheck(this, OperatorSymbol);\n\n                return _possibleConstructorReturn(this, (OperatorSymbol.__proto__ || Object.getPrototypeOf(OperatorSymbol)).call(this, x, y, width, height, value, SymbolTypes.OPERATOR));\n            }\n\n            return OperatorSymbol;\n        }(_Symbol9);\n\n        module.exports = OperatorSymbol;\n    }, { \"./Symbol\": 9, \"./enums/SymbolTypes\": 15 }], 7: [function (require, module, exports) {\n        var SymbolTypes = require('./enums/SymbolTypes');\n        var BracketTypes = require('./enums/BracketTypes');\n        var Expression = require('./Expression');\n        var _Symbol11 = require('./Symbol');\n        var RegionTypes = require('./enums/RegionTypes');\n        var Constant = require('./constant');\n        var SymbolFactory = require('./SymbolFactory');\n\n        var CENTRED = [\"a\", \"c\", \"e\", \"j\", \"m\", \"n\", \"o\", \"r\", \"s\", \"u\", \"v\", \"w\", \"x\", \"z\"];\n        var DECENDING = [\"g\", \"p\", \"q\", \"y\"]; // need these in when we have svgs for characters ready\n\n        var RecognitionTool = function () {\n            function RecognitionTool() {\n                _classCallCheck(this, RecognitionTool);\n            }\n\n            _createClass(RecognitionTool, null, [{\n                key: \"hor\",\n\n                /**\r\n                 * returns the next index of ls that is the next symbol in baseline given s\r\n                 * @param {[Symbol]} ls sorted baseline symbols\r\n                 * @param {...number} s the starting index\r\n                 * @returns the next baseline symbol index of ls, if nothing is found -1\r\n                 */\n                value: function hor(ls, s) {\n                    if (ls[s].type === SymbolTypes.FRACTION || ls[s].type === SymbolTypes.BRACKET && ls[s].bracketType == BracketTypes.OPEN || ls[s].type === SymbolTypes.OPERATOR) {\n                        var wall = ls[s].getWallCopy();\n                        var newWall = wall;\n                        newWall.left = ls[s].maxX;\n                        var st = RecognitionTool.start(ls, newWall);\n                        if (st == -1) {\n                            return -1;\n                        }\n                        return RecognitionTool.overlap(st, ls[s].wall, ls);\n                    }\n                    var index = 0;\n                    while (index < ls.length) {\n                        if (RecognitionTool.isInRegion(ls[s].wall, ls[index]) && !ls[index].marked) {\n                            if (ls[s].maxX <= ls[index].minX) {\n                                if (ls[s].minY + 2 / 5 * ls[s].height <= ls[index].y && ls[index].y < ls[s].maxY - ls[s].height * 1 / 5) return RecognitionTool.overlap(index, ls[s].wall, ls);\n                            }\n                        }\n                        index++;\n                    }\n                    return -1;\n                }\n\n                /**\r\n                 * Returns the starting index of Baseline Tree given the boundaries in wall.\r\n                 * @param {[Symbol]} ls \r\n                 * @param {Object} wall \r\n                 * @returns index or -1 if not found any starting index.\r\n                 */\n\n            }, {\n                key: \"start\",\n                value: function start(ls, wall) {\n                    var leftMostIndex = -1;\n                    var limitIndex = -1;\n                    var i = 0;\n                    var overlapIndex = -1;\n                    var n = ls.length;\n                    while (leftMostIndex == -1 && i < n) {\n                        if (!ls[i].marked && RecognitionTool.isInRegion(wall, ls[i])) {\n                            leftMostIndex = i;\n                        } else {\n                            i += 1;\n                        }\n                    }\n\n                    if (leftMostIndex == -1 || limitIndex == leftMostIndex) {\n                        return leftMostIndex;\n                    }\n                    while (i < n && limitIndex == -1) {\n                        if (!ls[i].marked && ls[i].type === SymbolTypes.LIMIT && RecognitionTool.isInRegion(wall, ls[i])) limitIndex = i;else i += 1;\n                    }\n\n                    if (limitIndex == -1 || limitIndex == leftMostIndex) {\n                        return RecognitionTool.overlap(leftMostIndex, wall, ls);\n                    }\n\n                    var upperThreshold = ls[limitIndex].maxY;\n                    var lowerThreshold = ls[limitIndex].minY;\n                    while (i > leftMostIndex) {\n                        i = i - 1;\n                        if (ls[i].y < upperThreshold && ls[i].y >= lowerThreshold) {\n                            overlapIndex = i;\n                        }\n                    }\n                    if (overlapIndex < limitIndex && overlapIndex != -1) {\n                        return RecognitionTool.overlap(leftMostIndex, wall, ls);\n                    } else {\n                        return RecognitionTool.overlap(limitIndex, wall, ls);\n                    }\n                }\n\n                /**\r\n                 * Returns the main index after checking vertically for any overlap\r\n                 * @param {number} index main index \r\n                 * @param {*} wall boundary\r\n                 * @param {[Symbol]} ls list of Symbols\r\n                 * @returns the mainline's index in ls\r\n                 */\n\n            }, {\n                key: \"overlap\",\n                value: function overlap(index, wall, ls) {\n                    var i = index;\n                    var top = wall.top;\n                    var bottom = wall.bottom;\n                    var stop = false;\n                    var n = ls.length;\n                    var maxLength;\n                    if (ls[index].type === SymbolTypes.FRACTION) {\n                        maxLength = ls[index].width;\n                    } else {\n                        maxLength = ls[index].width;\n                    }\n\n                    var mainLine = -1;\n                    while (i > 0 && !stop) {\n                        if (ls[i - 1].maxX < ls[index].minX) {\n                            stop = true;\n                        } else {\n                            i -= 1;\n                        }\n                    }\n                    while (i < n && ls[i].minX < ls[index].maxX) {\n                        if (!ls[i].marked && ls[i].type === SymbolTypes.Fraction && ls[i].y > top && ls[i].y <= bottom && ls[i].minX <= ls[index].x && ls[i].width > maxLength) {\n                            maxLength = ls[i].width;\n                            mainLine = i;\n                        } else {\n                            i++;\n                        }\n                    }\n\n                    if (mainLine == -1) {\n                        return index;\n                    } else {\n                        return mainLine;\n                    }\n                }\n\n                /**\r\n                 * Returns true iff the element is in the wall.\r\n                 * @param {*} wall \r\n                 * @param {*} element \r\n                 * @returns true iff element is in the wall.\r\n                 */\n\n            }, {\n                key: \"isInRegion\",\n                value: function isInRegion(wall, element) {\n                    if (wall.left <= element.x) {\n                        if (element.x < wall.right) {\n                            if (wall.top <= element.y) {\n                                if (element.y <= wall.bottom) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                }\n\n                /**\r\n                 * Returns a Baseline structure tree constructed given a sorted array of Symbols\r\n                 * @param {[Symbol]} [ls] sorted array of svg elements, if not given graps all on svg Canvas\r\n                 * @returns {Expression}\r\n                 */\n\n            }, {\n                key: \"parse\",\n                value: function parse() {\n                    var ls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n                    if (!ls) {\n                        ls = [];\n                        var eqns = svgCanvas.getSelectedElems().slice(0);\n                        if (eqns.__proto__.length == 0) {\n                            eqns = document.querySelectorAll('[id^=\"svg_eqn_\"]');\n                        }\n                        for (var _i = 0; _i < eqns.length; _i++) {\n                            var e = SymbolFactory.make(eqns[_i]);\n                            if (e) {\n                                ls.push(e);\n                            }\n                        }\n                    }\n                    ls.sort(function (a, b) {\n                        var result = a.minX - b.minX;\n                        if (result == 0) {\n                            return a.minY - b.minY;\n                        }\n                        return result;\n                    });\n\n                    var expression = new Expression();\n                    var stack = [];\n                    var queue = [];\n                    var temp1, temp2;\n                    var parent, symbol, relation;\n                    var wall = expression.wall;\n\n                    var s = RecognitionTool.start(ls, wall);\n\n                    if (s != -1) {\n                        ls[s].setWall(wall); //deep copy\n                        queue.push([s, expression]);\n                        ls[s].marked = true;\n                    }\n                    while (queue.length != 0) {\n                        while (queue.length != 0) {\n                            var _queue$shift = queue.shift();\n\n                            var _queue$shift2 = _slicedToArray(_queue$shift, 2);\n\n                            temp1 = _queue$shift2[0];\n                            parent = _queue$shift2[1];\n\n                            symbol = ls[temp1];\n                            symbol.marked = true;\n                            parent.symbols.push(symbol);\n                            stack.push([temp1, symbol]);\n                            wall = ls[temp1].wall;\n                            temp2 = RecognitionTool.hor(ls, temp1);\n                            while (temp2 != -1) {\n                                var oldWall = ls[temp1].wall;\n                                ls[temp2].setWall(oldWall);\n                                symbol = ls[temp2];\n                                var parentSize = parent.symbols.length;\n                                // if (symbol.value === \"m\" && parentSize >= 2 && parent.symbols[parentSize - 1].value === \"i\" && parent.symbols[parentSize - 2].value === \"l\") {\n                                //     var iSymbol = parent.symbols[parentSize - 1];\n                                //     var lSymbol = parent.symbols[parentSize - 2];\n                                //     var newX = lSymbol.minX;\n                                //     var newY = lSymbol.minY;\n                                //     var newWidth = symbol.x + symbol.width - newX;\n                                //     var newHeight = lSymbol.height;\n                                //     var newLimitSymbol = new LimitSymbol(newX, newY, newWidth, newHeight, \"lim\");\n                                //     newLimitSymbol.setWall(oldWall);\n                                //     newLimitSymbol.subSymbols = [lSymbol, iSymbol, symbol]; // fix when moving aronud actual symbols.\n                                //     symbol = newLimitSymbol;\n                                //     ls[temp2] = symbol;\n                                //     //console.log(ls.popls.indexOf(parent.symbols[parentSize -2]))\n                                //     //console.log(ls.indexOf(parent.symbols[parentSize -1]))\n                                //     stack.splice(stack.indexOf([ls.indexOf(lSymbol), lSymbol]), 1);\n                                //     stack.splice(stack.indexOf([ls.indexOf(iSymbol), iSymbol]), 1);\n                                //     parent.symbols.pop();\n                                //     parent.symbols.pop();\n                                // }\n                                parent.symbols.push(symbol);\n                                stack.push([temp2, symbol]);\n                                ls[temp1].wall.right = ls[temp2].minX;\n                                if (ls[temp2].type === SymbolTypes.LIMIT && (ls[temp1].type === SymbolTypes.BRACKET || ls[temp1].type === SymbolTypes.FRACTION)) {\n                                    ls[temp2].wall.left = ls[temp1].maxX;\n                                }\n                                temp1 = temp2;\n                                ls[temp1].marked = true;\n                                temp2 = RecognitionTool.hor(ls, temp1);\n                            }\n                            stack.push(\"EOBL\");\n                            while (stack.length != 0) {\n                                if (stack[stack.length - 1] === \"EOBL\") {\n                                    stack.pop();\n                                }\n\n                                var _stack$pop = stack.pop();\n\n                                var _stack$pop2 = _slicedToArray(_stack$pop, 2);\n\n                                temp1 = _stack$pop2[0];\n                                symbol = _stack$pop2[1];\n\n                                var top = symbol.wall.top;\n                                var bottom = symbol.wall.bottom;\n                                var si = parent.symbols.indexOf(symbol);\n                                var right = si == parent.symbols.length - 1 ? symbol.wall.right : parent.symbols[si + 1].minX;\n                                var left = symbol.minX;\n                                if (symbol.type === Constant.SYMBOL_TYPES.LIMIT) {\n                                    if (si == 0) {\n                                        left = wall.left;\n                                    } else if (parent.symbols[si - 1].type === Constant.SYMBOL_TYPES.BRACKET) {\n                                        left = parent.symbols[si - 1].maxX;\n                                    } else if (parent.symbols[si - 1].type === Constant.SYMBOL_TYPES.FRACTION) {\n                                        left = parent.symbols[si - 1].maxX;\n                                    }\n                                }\n\n                                var minX = symbol.minX;\n                                var maxX = symbol.maxX;\n                                var minY = symbol.minY;\n                                var maxY = symbol.maxY;\n                                var upperThreshold = minY + 2 / 5 * (maxY - minY);\n                                var lowerThreshold = maxY - 2 / 5 * (maxY - minY);\n\n                                var above = [[minX, minY], [maxX, top], RegionTypes.ABOVE];\n                                var below = [[minX, bottom], [maxX, maxY], RegionTypes.BELOW];\n                                var supers = [[maxX, upperThreshold], [right, top], RegionTypes.SUPER];\n                                var subsc = [[maxX, bottom], [right, lowerThreshold], RegionTypes.SUBSC];\n                                var tleft = [[left, upperThreshold], [minX, top], RegionTypes.TLEFT];\n                                var bleft = [[left, bottom], [minX, lowerThreshold], RegionTypes.BLEFT];\n                                var contains = [[minX, maxY], [maxX, minY], RegionTypes.CONTAINS];\n                                var region_walls = [above, below, supers, subsc, tleft, bleft, contains];\n                                var regions = [RegionTypes.ABOVE, RegionTypes.BELOW, RegionTypes.SUPER, RegionTypes.SUBSC, RegionTypes.TLEFT, RegionTypes.BLEFT, RegionTypes.CONTAINS];\n                                for (var i = 0; i < regions.length; i++) {\n                                    symbol.region[regions[i]].setWall(region_walls[i]);\n                                    temp2 = RecognitionTool.start(ls, symbol.region[regions[i]].wall);\n                                    if (temp2 != -1) {\n                                        ls[temp2].marked = true;\n                                        ls[temp2].setWall(symbol.region[regions[i]].wall);\n                                        relation = symbol.region[regions[i]];\n                                        queue.push([temp2, relation]);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return expression;\n                }\n\n                /**\r\n                 * Given an Expression (Baseline Structure Tree), generates and returns TEX\r\n                 * @param {Expression} [bst] Baseline Structure Tree\r\n                 */\n\n            }, {\n                key: \"getTex\",\n                value: function getTex() {\n                    var bst = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RecognitionTool.parse();\n\n                    var result = \"\";\n                    if (bst.symbols) {\n\n                        if (bst.region_name == RegionTypes.ROOT) {\n                            result += \"$$\";\n                        }\n                        for (var i = 0; i < bst.symbols.length; i++) {\n                            var lastTex = RecognitionTool.getTex(bst.symbols[i]);\n                            result += lastTex;\n                        }\n                        if (result.indexOf(\"lim\") >= 0) {\n                            result = result.replace('li ', ' ');\n                        }\n\n                        if (bst.region_name == RegionTypes.ROOT) {\n                            result += \"$$\";\n                            result = result.replace(/arcsin|arccos|arctan|cosh|sinh|tanh|cos|sin|tan/gi, function (x) {\n                                return \" \\\\\" + x + \" \";\n                            });\n                        }\n                        return result;\n                    }\n                    var value = bst.value;\n                    var symbol = bst;\n                    var type = bst.type;\n                    if (type === SymbolTypes.LIMIT) {\n                        result += Constant.TEX_TEXT[value] + \" \";\n                        if (bst.hasAnyBottom()) result += \"_{\" + RecognitionTool.getTex(bst.region[RegionTypes.BLEFT]) + RecognitionTool.getTex(bst.region[RegionTypes.BELOW]) + RecognitionTool.getTex(bst.region[RegionTypes.SUBSC]) + \"} \";\n                        if (bst.hasAnyTop()) result += \"^{\" + RecognitionTool.getTex(bst.region[RegionTypes.TLEFT]) + RecognitionTool.getTex(bst.region[RegionTypes.ABOVE]) + RecognitionTool.getTex(bst.region[RegionTypes.SUPER]) + \"} \";\n                    } else if (type === SymbolTypes.FRACTION) {\n                        if (bst.hasAnyTop() && bst.hasAnyBottom()) {\n                            result += Constant.TEX_TEXT[\"fraction\"];\n                            result += \"{\";\n                            result += RecognitionTool.getTex(bst.region[RegionTypes.TLEFT]) + RecognitionTool.getTex(bst.region[RegionTypes.ABOVE]) + RecognitionTool.getTex(bst.region[RegionTypes.SUPER]);\n                            result += \"}{\";\n                            result += RecognitionTool.getTex(bst.region[RegionTypes.BLEFT]) + RecognitionTool.getTex(bst.region[RegionTypes.BELOW]) + RecognitionTool.getTex(bst.region[RegionTypes.SUBSC]);\n                            result += \"} \";\n                        } else if (bst.hasAnyBottom()) {\n                            result += Constant.TEX_TEXT['overline'];\n                            result += \"{\" + RecognitionTool.getTex(bst.region[RegionTypes.BLEFT]) + RecognitionTool.getTex(bst.region[RegionTypes.BELOW]) + RecognitionTool.getTex(bst.region[RegionTypes.SUBSC]) + \"}\";\n                        } else if (bst.hasAnyTop()) {\n                            result += Constant.TEX_TEXT['underline'];\n                            result += \"{\" + RecognitionTool.getTex(bst.region[RegionTypes.TLEFT]) + RecognitionTool.getTex(bst.region[RegionTypes.ABOVE]) + RecognitionTool.getTex(bst.region[RegionTypes.SUPER]) + \"}\";\n                        } else {\n                            result += ' - ';\n                        }\n                    } else if (type === SymbolTypes.ROOT) {\n                        result += Constant.TEX_TEXT[value] + \"{\" + RecognitionTool.getTex(bst.region[RegionTypes.CONTAINS]) + \"} \";\n                        if (bst.region[RegionTypes.SUPER].hasElement()) {\n                            result += \"^{\" + RecognitionTool.getTex(bst.region[RegionTypes.SUPER]) + \"} \";\n                        }\n                        if (bst.region[RegionTypes.SUBSC].hasElement()) {\n                            result += \"_{\" + RecognitionTool.getTex(bst.region[RegionTypes.SUBSC]) + \"} \";\n                        }\n                    } else if (type === SymbolTypes.BRACKET) {\n                        result += Constant.TEX_TEXT[value];\n                        if (symbol.bracketType == Constant.BRACKET_TYPES.CLOSE) {\n                            if (bst.region[RegionTypes.SUPER].hasElement()) {\n                                result += \"^{\" + RecognitionTool.getTex(bst.region[RegionTypes.SUPER]) + \"}\";\n                            }\n                            if (bst.region[RegionTypes.SUBSC].hasElement()) {\n                                result += \"_{\" + RecognitionTool.getTex(bst.region[RegionTypes.SUBSC]) + \"} \";\n                            }\n                        }\n                    } else if (type == SymbolTypes.OPERATOR) {\n                        result += Constant.TEX_TEXT[value];\n                    } else {\n                        result += value;\n                        if (bst.region[RegionTypes.SUPER].hasElement()) {\n                            result += \"^{\" + RecognitionTool.getTex(bst.region[RegionTypes.SUPER]) + \"}\";\n                        }\n                        if (bst.region[RegionTypes.SUBSC].hasElement()) {\n                            result += \"_{\" + RecognitionTool.getTex(bst.region[RegionTypes.SUBSC]) + \"}\";\n                        }\n                    }\n                    return result;\n                }\n            }]);\n\n            return RecognitionTool;\n        }();\n\n        module.exports = RecognitionTool;\n    }, { \"./Expression\": 3, \"./Symbol\": 9, \"./SymbolFactory\": 10, \"./constant\": 12, \"./enums/BracketTypes\": 13, \"./enums/RegionTypes\": 14, \"./enums/SymbolTypes\": 15 }], 8: [function (require, module, exports) {\n        var _Symbol12 = require('./Symbol');\n        var SymbolTypes = require('./enums/SymbolTypes');\n\n        var RootSymbol = function (_Symbol13) {\n            _inherits(RootSymbol, _Symbol13);\n\n            /**\r\n             * Construct RootSymbol instance.\r\n             * //might require name change to a line\r\n             * @param x\r\n             * @param y\r\n             * @param width\r\n             * @param height\r\n             * @param value\r\n             */\n            function RootSymbol(x, y, width, height, value) {\n                _classCallCheck(this, RootSymbol);\n\n                return _possibleConstructorReturn(this, (RootSymbol.__proto__ || Object.getPrototypeOf(RootSymbol)).call(this, x, y, width, height, value, SymbolTypes.ROOT));\n            }\n\n            return RootSymbol;\n        }(_Symbol12);\n\n        module.exports = RootSymbol;\n    }, { \"./Symbol\": 9, \"./enums/SymbolTypes\": 15 }], 9: [function (require, module, exports) {\n        var SymbolTypes = require('./enums/SymbolTypes');\n        var RegionTypes = require('./enums/RegionTypes');\n        var Expression = require('./Expression');\n\n        var _Symbol14 = function () {\n            /**\r\n             * Abstract Symbol instance.\r\n             * //might require name change to a line\r\n             * @param x\r\n             * @param y\r\n             * @param width\r\n             * @param height\r\n             * @param value\r\n             * @param type\r\n             */\n            function _Symbol14(x, y, width, height, value, type) {\n                _classCallCheck(this, _Symbol14);\n\n                if (this.constructor === _Symbol14) {\n                    throw new Error(\"Abstract Class Instatiation Error\");\n                }\n                this.type = type;\n                this.minX = x;\n                this.minY = y;\n                this.maxX = x + width;\n                this.maxY = y + height;\n                this.value = value;\n                this.width = width;\n                this.height = height;\n                this.x = (this.minX + this.maxX) / 2;\n                this.y = (this.minY + this.maxY) / 2;\n                this.region = {};\n                for (var region in RegionTypes) {\n                    this.region[RegionTypes[region]] = new Expression(RegionTypes[region]);\n                }\n                this.wall = {};\n                this.size = width * height;\n            }\n\n            /**\r\n             * Returns true iff it has any elements at top\r\n             * @returns {boolean}\r\n             */\n\n\n            _createClass(_Symbol14, [{\n                key: \"hasAnyTop\",\n                value: function hasAnyTop() {\n                    return this.region[RegionTypes.TLEFT].hasElement() || this.region[RegionTypes.ABOVE].hasElement() || this.region[RegionTypes.SUPER].hasElement();\n                }\n\n                /**\r\n                 * Returns true iff it has any elements at bottom\r\n                 * @returns {boolean}\r\n                 */\n\n            }, {\n                key: \"hasAnyBottom\",\n                value: function hasAnyBottom() {\n                    return this.region[RegionTypes.BLEFT].hasElement() || this.region[RegionTypes.BELOW].hasElement() || this.region[RegionTypes.SUBSC].hasElement();\n                }\n\n                /** \r\n                 * Sets the wall of this Symbol.\r\n                 * @param wall\r\n                 */\n\n            }, {\n                key: \"setWall\",\n                value: function setWall(wall) {\n                    this.wall.top = wall.top;\n                    this.wall.bottom = wall.bottom;\n                    this.wall.left = wall.left;\n                    this.wall.right = wall.right;\n                }\n                /**\r\n                 * Returns a copy of this Symbol's wall\r\n                 * @returns {Object}\r\n                 */\n\n            }, {\n                key: \"getWallCopy\",\n                value: function getWallCopy() {\n                    return {\n                        'top': this.wall.top,\n                        'bottom': this.wall.bottom,\n                        'left': this.wall.left,\n                        'right': this.wall.right\n                    };\n                }\n                /**\r\n                 * Applies func for each regions and symbol.\r\n                 * @param func\r\n                 * @param regionCondFunc\r\n                 * @param condFunc\r\n                 */\n\n            }, {\n                key: \"apply\",\n                value: function apply(func, regionCondFunc, condFunc) {\n                    for (var region_name in this.region) {\n                        if (this.region[region_name].hasElement()) {\n                            var b = regionCondFunc(this.region[region_name]);\n                            var combinedCondFunc = function combinedCondFunc(symbol) {\n                                var res = b && condFunc(symbol);\n                                return res;\n                            };\n                            //if(b)\n                            //  this.region[region_name].apply(func, function(region){return true}, combinedCondFunc);\n                            //else\n                            this.region[region_name].apply(func, regionCondFunc, combinedCondFunc);\n                        }\n                    }\n                }\n            }]);\n\n            return _Symbol14;\n        }();\n\n        module.exports = _Symbol14;\n    }, { \"./Expression\": 3, \"./enums/RegionTypes\": 14, \"./enums/SymbolTypes\": 15 }], 10: [function (require, module, exports) {\n        var _Symbol15 = require(\"./Symbol\");\n        var AlphanumericSymbol = require('./AlphanumericSymbol');\n        var BracketSymbol = require('./BracketSymbol');\n        var FractionSymbol = require('./FractionSymbol');\n        var LimitSymbol = require('./LimitSymbol');\n        var OperatorSymbol = require('./OperatorSymbol');\n        var RootSymbol = require('./RootSymbol');\n        var SymbolTypes = require('./enums/SymbolTypes');\n        var Constant = require('./constant');\n\n        /**\r\n             * returns the type of Symbol given a string value\r\n             * @param {String} value\r\n             * @return {number}\r\n             */\n        function getSymbolType(value) {\n            if (Constant.BRACKET.indexOf(value) != -1) {\n                return SymbolTypes.BRACKET;\n            }\n            if (Constant.LINE.indexOf(value) != -1) {\n                return SymbolTypes.FRACTION;\n            }\n            if (Constant.ROOT.indexOf(value) != -1) {\n                return SymbolTypes.ROOT;\n            }\n            if (Constant.LIMIT.indexOf(value) != -1) {\n                return SymbolTypes.LIMIT;\n            }\n            if (Constant.OPERATOR.indexOf(value) != -1) {\n                return SymbolTypes.OPERATOR;\n            }\n            return SymbolTypes.ALPHANUMERIC;\n        }\n\n        var SymbolFactory = function () {\n            function SymbolFactory() {\n                _classCallCheck(this, SymbolFactory);\n            }\n\n            _createClass(SymbolFactory, null, [{\n                key: \"make\",\n\n                /**\r\n                 * Creates an Apropriate Symbol.\r\n                 * @param {DOM} elem\r\n                 * @returns {Symbol}\r\n                 */\n                value: function make(elem) {\n                    if (elem.textContent == \" \" || elem.tagName == \"g\") return null;\n                    var rect = svgedit.utilities.getBBox(elem);\n                    var x = rect.x;\n                    var y = rect.y;\n                    var width = rect.width;\n                    var height = rect.height;\n                    var value = elem.nodeName == \"path\" ? elem.id.split('_')[3] : elem.textContent;\n\n                    var type = getSymbolType(value);\n                    var symbol;\n                    switch (type) {\n                        case SymbolTypes.BRACKET:\n                            symbol = new BracketSymbol(x, y, width, height, value);\n                            break;\n                        case SymbolTypes.FRACTION:\n                            symbol = new FractionSymbol(x, y, width, height, value);\n                            break;\n                        case SymbolTypes.ROOT:\n                            symbol = new RootSymbol(x, y, width, height, value);\n                            break;\n                        case SymbolTypes.LIMIT:\n                            symbol = new LimitSymbol(x, y, width, height, value);\n                            break;\n                        case SymbolTypes.ALPHANUMERIC:\n                            symbol = new AlphanumericSymbol(x, y, width, height, value);\n                            break;\n                        case SymbolTypes.OPERATOR:\n                            symbol = new OperatorSymbol(x, y, width, height, value);\n                            break;\n                        default:\n                            throw \"Cannot have any other symbol than type.\";\n                            break;\n                    }\n                    symbol.id = elem.id;\n                    return symbol;\n                }\n            }]);\n\n            return SymbolFactory;\n        }();\n\n        module.exports = SymbolFactory;\n    }, { \"./AlphanumericSymbol\": 1, \"./BracketSymbol\": 2, \"./FractionSymbol\": 4, \"./LimitSymbol\": 5, \"./OperatorSymbol\": 6, \"./RootSymbol\": 8, \"./Symbol\": 9, \"./constant\": 12, \"./enums/SymbolTypes\": 15 }], 11: [function (require, module, exports) {\n        window.Tool = {\n            RecognitionTool: require('./RecognitionTool')\n        };\n    }, { \"./RecognitionTool\": 7 }], 12: [function (require, module, exports) {\n        var _TEX_TEXT;\n\n        module.exports = {\n            REGION_NAMES: {\n                'ROOT': 'root',\n                'TLEFT': 'tleft',\n                'ABOVE': 'above',\n                'SUPERS': 'supers',\n                'CONTAINS': 'contains',\n                'BLEFT': 'bleft',\n                'BELOW': 'below',\n                'SUSC': 'subsc'\n            },\n            SYMBOL_TYPES: {\n                'ALPHANUMERIC': 'text',\n                'TEXT': 'text',\n                'LIMIT': 'limit',\n                'FRACTION': 'fraction',\n                'BRACKET': 'bracket',\n                'ROOT': 'root',\n                'OPERATOR': 'operator'\n            },\n            BRACKET_TYPES: {\n                'OPEN': 'open',\n                'CLOSE': 'close'\n            },\n\n            TEX_TEXT: (_TEX_TEXT = {\n                'sum': ' \\\\sum ',\n                'lim': ' \\\\lim ',\n                '∑': ' \\\\sum ',\n                'fraction': ' \\\\frac ',\n                'root': ' \\\\sqrt ',\n                'integral': ' \\\\int',\n                '∫': ' \\\\int ',\n                'lbracket': ' \\\\left( ',\n                'rbracket': ' \\\\right) ',\n                '(': ' \\\\left( ',\n                ')': ' \\\\right) ',\n                '±': ' \\\\pm ',\n                '∓': ' \\\\mp ',\n                '+': ' + ',\n                '×': ' \\\\times ',\n                '—': ' - ',\n                'overline': ' \\\\overline ',\n                'underline': \" \\\\underline \",\n                '<': ' \\\\lt ',\n                '≤': ' \\\\le ',\n                '>': ' \\\\gt ',\n                '≥': ' \\\\ge ',\n                '=': ' = ',\n                '→': ' \\\\to '\n            }, _defineProperty(_TEX_TEXT, \"lim\", ' \\\\lim '), _defineProperty(_TEX_TEXT, '->', '\\\\to '), _TEX_TEXT),\n            BRACKET: [\"lbracket\", \"(\", \")\", \"rbracket\"],\n            LINE: [\"fraction\", \"—\"],\n            ROOT: [\"root\"],\n            LIMIT: [\"sum\", \"∑\", \"integral\", \"∫\", \"lim\"],\n            OPERATOR: [\"+\", \"±\", \"∓\", '<', '>', '≤', '≥', '=', '×', '→']\n        };\n    }, {}], 13: [function (require, module, exports) {\n        \"use strict\";\n\n        module.exports = {\n            OPEN: \"open\",\n            CLOSE: \"close\"\n        };\n    }, {}], 14: [function (require, module, exports) {\n        module.exports = {\n            ROOT: \"ROOT\",\n            TLEFT: \"TLEFT\",\n            ABOVE: \"ABOVE\",\n            SUPER: \"SUPER\",\n            CONTAINS: \"CONTAINS\",\n            BLEFT: \"BLEFT\",\n            BELOW: \"BELOW\",\n            SUBSC: \"SUBSC\"\n        };\n    }, {}], 15: [function (require, module, exports) {\n        \"use strict\";\n\n        module.exports = {\n            ALPHANUMERIC: \"ALPHANUMERIC\", // this needs to be categorized by decending/ascending characters\n            BRACKET: \"BRACKET\",\n            FRACTION: \"FRACTION\",\n            LIMIT: \"LIMIT\",\n            OPERATOR: \"OPERATION\",\n            ROOT: \"ROOT\"\n        };\n    }, {}] }, {}, [11]);"]}